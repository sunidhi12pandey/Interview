1. Walk me through your current project architecture and your role in it. 
We’re working on a microservices-based application that runs on Google Kubernetes Engine (GKE). The frontend is built using React and Angular, and it’s exposed to users through an HTTPS Load Balancer. The backend runs as Node.js containers inside Kubernetes. For storage we use postgres , and for logs and monitoring we rely on the ELK stack. 

My role is to manage the infrastructure with Terraform, and I take care of the build, deployment, and release process using CI/CD pipelines in GitHub Actions 

Branching Strategy (Your Answer Reframed) 
In our setup, we follow an environment-based branching strategy aligned with our release flow. We maintain dev, stg, npr, and prd branches. 

The first release always goes into the dev environment, where deployments are dockerized using Docker Compose. This allows us to test features quickly in a controlled setup. 

After a 1-day gap, the code is promoted to stg (staging). Here, some applications are still dockerized, while others are already hosted on GKE to test closer to production. 

With a 3-day gap, the release is promoted to the npr (non-production replica) environment, which is fully hosted on GKE and mirrors production more closely. 

Finally, after a 7-day gap of stability testing, the release is promoted to prd (production), also running on GKE.


CI/CD Pipelines (Your Answer Reframed) 
We use two types of pipelines in GitHub Actions — one for releases  and another for infrastructure automations. 

1. Release Pipeline (Zero Downtime, Rolling Upgrade) 
This pipeline is designed for safe application deployments and has five key stages: 

- Release DevOps engineer pushes code to the main branch and raises a pull request. 
- A custom pipeline runs code vulnerability scans (using Wiz) and builds the application. 
- Second in test stage, The application test in dockerized environment using Docker Compose. We run health checks (expecting HTTP 200 status) to ensure builds are valid. 
- Stage 3 Image Push & Security Scan: Validated Docker images are pushed to the Artifact Registry. Images undergo a second container security scan (Wiz) before deployment. 
- Deployment (Rolling Upgrade): The pipeline clones the release code. A rolling upgrade strategy is used to ensure zero downtime in production. 
- Stage five: Mail to the respective authorities. 

2. Automation Pipeline 
This pipeline handles infrastructure tasks and housekeeping. Examples include: 
- Creating VMs and applying labels. 
- Managing secrets for different environments. 
- Clearing caches during release cycles. 
- Hardening custom images to improve security posture. 
- Creating snapshots/volumes for backup and recovery 
